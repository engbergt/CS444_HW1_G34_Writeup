\title{Homework 4 - Group 34}

\author{
        Sean Caster,
        Joshua Sean Bell,
        Tarren Engberg
}
\date{June 8th, 2018}

\documentclass[titlepage,draftclsnofoot,onecolumn]{article}
\usepackage{geometry}
\geometry{letterpaper, margin=0.75in}

\begin{document}
\maketitle

\begin{abstract}
  Group 34 describes their experience implementing a SLOB best fit algorithm for memory management in the Linux Yocto environment as well as the experience of making a custom system call to gather SLOB information for analysis of the difference between the default first-fit and the best-fit algorithms.
\end{abstract}

\section*{Write Up}
Group 34 commands used, flag definitions and question answers.

\paragraph{Design}
To complete this assignement we have decided to first figure out how we want to transform the first-fit algorithm to be a best-fit algorithm. The first-fit algorithm simply looks for the first slot it comes across in the page that is big enough to fit and place the data. The best-fit method differs in that it searches the entire page for a large enough slot and also for the smallest of those slots that will fit the data. This best-fit method is designed to pack more densly, lowering the frequency of fragmentation. Once we have developed a modification to first-fit that makes it work as best-fit, we will build in a custom system call that allows us to record an enumeration of the fragmentation in memory so that the two algorithms may be compared for data density.

\paragraph{Version Control Log}
\texttt{
\begin{tabular}{|r|l|}
  \hline
  Commit: & 8324c16420be5f06e284ebfd7fa3b8b244037b3b \\ \cline{2-2}
  Author: & Tarren Engberg <tarren@outlook.com> \\ \cline{2-2}
  Date: & Thu Jun 7 11:04:38 2018 -0700 \\ \cline{2-2}
  Message: & added project design section and started work log section \\
  \hline
\end{tabular}
}

\paragraph{Work Log}
- We started by first examining the slob.c file in the mm directory in the Linux kernal. We found the function slob\_alloc and began tracing it through to try and understand how it is working so that we may make modifications to enable best-fit.

\paragraph{Main Point of the Assignment}
We believe the main purpose of this assignment is to first get familiarity with Linux memory management techniques by discovering how Linux handles memory allocation by default. Since we must alter the process by building in a best-fit solution, we'll need to have a good understanding of how first-fit works in order to effectively alter its fuctionality. Additionaly, we must use a technique to measure fragmentation between the two techniques. This will require us to develope a custom system call and go through the process of recording the fragmentation difference between the two algorithms when in use.

\paragraph{Our Approach}
Our approach to this assignment is to start with the slob.c file and edit the slob alloc section to use a different fit algorithm depending on a definition we define. When we have tested and found that the new algoritm is infact working, we will add the system call to measure the fragmentation difference and record the difference between the two methods to hopefully find that best-fit packs more densly.

\paragraph{Solution Correctness}
The solution correctness of this assignment will be measured by how much more densly the best-fit algorithm is able to pack data when compared to the first-fit algoritm. Our solution will be correct if we are able to show that this is the case since we know that it can be shown that the best-fit algorithm indeed packs more densly in theory.

\paragraph{What We Learned}
There were a number of key things that we learned by doing this assignment. By actually working hands-on with the memory management, we were able to get a better understanding of how memory allocation works. We also learned a lot about how system calls work in the Linux Kernel. Another key concept we gained more experience in is kernal debugging.

\paragraph{TA Steps to Follow}


\begin{enumerate}
	\item \texttt{source envivronment-setup-i586-poky-linux.csh}
	\item \texttt{monster}
	\item In the VM: user name=root
	\item \texttt{scp [your remote ssh address]:[your filepath]/linux-yocto-3.19/drivers/block/sbd.ko ./}
	\item \texttt{./insmod}
	\item \texttt{./mkfs}
	\item \texttt{./mount}
	\item \texttt{cd /mnt/ourmount/}
	\item \texttt{vi hi}
	\item Write some data to hi in vi
	\item Save changes to hi and wait for a something like "enc'ing ctxt: ptxt was: " to print to console (this indicates encryption is working)
	\item \texttt{vi hi} again to see that it has been encrypted
	\item \texttt{less -f /dev/sbd0}
	\item \texttt{P 800} (takes you a bit below the offset to to see the decrypted data)
  \end{enumerate}
  
  NOTE: steps 10-14 are necessary since accessing 'hi' through vi will load cached memory (meaning our altered disk read which holds the decryption function won't get called); however, less must query our filesystem normally, meaning sbd\_request will be called, leading to an instantiation of sbd\_transfer, where our decryption function lives.



\end{document}
